---
title: "Reimplement matching"
editor: visual
editor_options: 
  chunk_output_type: console
---

We use the R package `rgee` as an interface to Google Earth engine API [@aybar2020].

```{r}
setwd("replication_report")
# Sometime rgee does not find the right python env, so we specify it
reticulate::use_python("C:/Users/fbede/AppData/Local/r-miniconda/envs/rgee")
library(rgee) # accesses GEE through its python API
# Install rgeeExtra if not present
if (!("rgeeExtra" %in% installed.packages())) {
  remotes::install_github("r-earthengine/rgeeExtra")
}
library(rgeeExtra) # additional funcitonnalities
library(googledrive) # to download additional data from drive (facultative)
library(tidyverse)
ee_Initialize()
dir.create("gee")
```

We want to use the same data as Wolf et al. but to implement a different strategy that:

-   implies less manipulations steps that might be error prone;
-   relies on cloud data processing for very big datasets;
-   only relies on one language and configuration for local processing.

Therefore we plan to leverage Google Earth engine to the maximum by:

-   using the same data sources and processing than Wolf et al,;
-   add the other data that were obtained from different data sources;
-   better mask the data to reduce its size;
-   stack all the information in single multi-bands rasters;
-   slice the rasters by country and biome as these are matched separately;
-   download individual rasters to match them locally;
-   store the matched data into an efficient on-disk storage for later processing;
-   do the final regressions leveraging bigger than memory funcitonnalities of R.

# Load Biomes on Google Earth Engine and use them as masks

First we will fetch the biome descriptions from the resolve ecoregions.

```
//// ---- Union using the property ---- \\\\

// first get a list of all posible property values
var propVals = ee.List(WDPA.aggregate_array(nameProperty)).distinct();
// then make a feature the union of all features having the same propVal
var unionByProp = ee.FeatureCollection(propVals.map(function(propVal){
  var tempFC = WDPA.filter(ee.Filter.eq(nameProperty, propVal));
  var unionFC = tempFC.union(maxError); // specifying a max error overcomes issues with features of diff projection
  // cast the featureCollection (output union()) to a single feature
  return ee.Feature(unionFC.first()).set(nameProperty, propVal);
}));
```

```{r}
# Get ecoregions that include WWF biomes
all_ecoregions <- ee$FeatureCollection("RESOLVE/ECOREGIONS/2017")
# list biome names
all_biome_names <- ee$List(all_ecoregions$aggregate_array("BIOME_NAME"))$
  distinct() # keep only 1 per modality
biome_names$getInfo() # print
```

     [1] "Tropical & Subtropical Moist Broadleaf Forests"          
     [2] "Tropical & Subtropical Grasslands, Savannas & Shrublands"
     [3] "Flooded Grasslands & Savannas"                           
     [4] "Montane Grasslands & Shrublands"                         
     [5] "Deserts & Xeric Shrublands"                              
     [6] "Mangroves"                                               
     [7] "Mediterranean Forests, Woodlands & Scrub"                
     [8] "Tropical & Subtropical Dry Broadleaf Forests"            
     [9] "Tropical & Subtropical Coniferous Forests"               
    [10] "Temperate Broadleaf & Mixed Forests"                     
    [11] "Temperate Conifer Forests"                               
    [12] "Temperate Grasslands, Savannas & Shrublands"             
    [13] "N/A"                                                     
    [14] "Boreal Forests/Taiga"                                    
    [15] "Tundra"  


Wolf et al. specify that they focused on the following ones:

-   Tropical & Subtropical Moist Broadleaf Forests
-   Tropical & Subtropical Dry Broadleaf Forests
-   Tropical & Subtropical Coniferous Forests
-   Temperate Broadleaf & Mixed Forests
-   Temperate Conifer Forests
-   Boreal Forests/Taiga
-   Mangroves

```{r}
# Filter selected biomes
select_ecoregs <- all_ecoregions$
  filter("BIOME_NAME == 'Tropical & Subtropical Moist Broadleaf Forests' ||
          BIOME_NAME == 'Tropical & Subtropical Dry Broadleaf Forests' ||
          BIOME_NAME == 'Tropical & Subtropical Coniferous Forests' ||
          BIOME_NAME == 'Temperate Broadleaf & Mixed Forests' ||
          BIOME_NAME == 'Temperate Conifer Forests' ||
          BIOME_NAME == 'Boreal Forests/Taiga' ||
          BIOME_NAME == 'Mangroves'")

```

![selected ecoregions from google earth engine](img/selected_ecoregions.png)

# Clip Hansen data with biome polygons

Instead of downloading and processing all the GFC data like Wolf and al., we instead keep only the data located within the perimeter of the biomes of interest.

```{r}
scale <- 0.008983153 # From Wolf et al. 2021
drive_folder <- "rgee"
local_folder <- "temp"

# Hansen/GFC -------------------------------------------------------------------
gfc <- ee$Image("UMD/hansen/global_forest_change_2018_v1_6")

# Cover other try
gfc_mask <- gfc$select("datamask")$eq(1)
cover <-  gfc$select("treecover2000")$
  updateMask(gfc_mask)$
  clipToCollection(select_ecoregs)
Map$addLayer(cover, list(bands = "treecover2000"), "green")
```

![forest data from selected ecoregions](img/filtered_forest_data.png)

# Stack information as bands in a single raster

Wolf et al. downloaded each information source in a separate raster, that they later on joined. We find easier and less error-prone to stack all the information as bands of the same raster. The data might be downloaded in separate files for different regions, but for the same regions, all the complementary information is attached to the same pixels with the same resolution (alias, a "clean" table).

```{r}
## Lossyear ------------------------------------
lossyear <- gfc$select("lossyear")
lossyear <- lossyear$updateMask(lossyear$neq(0))$ # maskout 0
  reduceResolution(reducer = ee$Reducer$mode(), 
                                      bestEffort = TRUE)$
  toInt()

## Loss --------------------------------------------
loss <- gfc$select("loss")$
  reduceResolution(reducer = ee$Reducer$mean(), bestEffort = TRUE)$
  toInt() # or to Int32?

# Other rasters fetched from GEE by wold et al. --------------------------------
elev <- ee$Image("USGS/GTOPO30")$
  toInt()

slope <- ee$Terrain$slope(elev)

travel_time <- ee$Image("Oxford/MAP/accessibility_to_cities_2015_v1_0")$
  toInt()
gpw <- paste0("CIESIN/GPWv411/GPW_UNWPP-Adjusted_Population_Density/",
              "gpw_v4_population_density_adjusted_to_2015_", 
              "unwpp_country_totals_rev11_2000_30_sec")

pop_dens <- ee$Image(gpw)$
  select("unwpp-adjusted_population_density")$
  focal_mean(radius = 20e3, kernelType = "circle", 
                                units = "meters")$
  toInt()

countries <- ee$FeatureCollection("USDOS/LSIB_SIMPLE/2017")
countries_img <- countries$
  filter(ee$Filter$notNull(list("ADM0_CODE")))$
  reduceToImage(properties = list("ADM0_CODE"), reducer = ee$Reducer$first())

wdpa <- ee$FeatureCollection("WCMC/WDPA/current/polygons")$
  set("PA", 1)

wdpa_buffer <- wdpa.buffer(10000)$ # 10km buffer
  set("PA_buffer", 1)

wdpa_yr <- wdpa$
  filter(ee$Filter$notNull(list("STATUS_YR")))$
  reduceToImage(properties = list("STATUS_YR"), reducer = ee$Reducer$first())

# stack bands into a single raster and export ----------------------------------
combined <- cover$addBands(c(lossyear, loss, elev, slope, travel_time, 
                             pop_dens, countries_img, wdpa, wdpa_yr, 
                             wdpa_buffer))$
  rename(c("cover", "lossyear", "loss", "elev", "slope", "travel_time", 
           "pop_dens", "country", "PA", "PA_status_yr", "PA_buffer"))
```

# Add countries and PAs

```{r}
library(sf)
library(tmap)

#select_countries <- countries$filterBounds(select_ecoregs$union())
countries_download <- ee_as_sf(countries, 
                               dsn = "gee/countries.geojson", 
                               container = "rgee", via = "drive", lazy = TRUE)
ecoregions_download <- ee_as_sf(select_ecoregs, 
                                dsn = "gee/select_ecoregs.geojson", 
                                container = "rgee", via = "drive", lazy = TRUE)
ee_utils_future_value(countries_download)
ee_utils_future_value(ecoregions_download)
my_countries <- st_read("gee/countries.geojson")
my_ecoregions <- st_read("gee/select_ecoregs.geojson")


table_biomes <- my_ecoregions %>%
  st_drop_geometry() %>%
  select(BIOME_NAME, BIOME_NUM) %>%
  unique()



mdg <- my_countries %>%
  filter(country_na == "Madagascar")
mangroves <- my_ecoregions %>%
  filter(BIOME_NAME == "Mangroves") %>%
  st_make_valid()

mdg %>%
  tm_shape() +
  tm_polygons()
mangroves %>%
  tm_shape() +
  tm_polygons()

mdg_part <- mdg %>%
  st_intersection(mangroves)

mdg_part %>%
  tm_shape() +
  tm_polygons()



```

# Load deforestation drivers

```{r}

# Drivers

wwf_ecoregions %>%
  st_drop_geometry() %>%
  group_by(BIOME) %>%
  summarise(n_distinct = n_distinct(BIOME),
            n = n())
wwf_ecoregions %>%
  st_drop_geometry() %>%
  group_by(ECO_NAME) %>%
  summarise(n_distinct = n_distinct(ECO_NAME),
            n = n())

```

Load GEE data

```{r}


```
